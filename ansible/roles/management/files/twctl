#!/bin/bash

# Ensure we can parse all command output
export LANG=C

# Find Ansible configuration
if [ -d ~/platform/ansible ] ; then
	ANSIBLE_DIR=~/platform/ansible
elif [ -d ~teamwire/platform/ansible ] ; then
	ANSIBLE_DIR=~teamwire/platform/ansible
else
	echo "Cannot find platform directory."
	exit 1
fi

CONFIG_FILE="${ANSIBLE_DIR}/group_vars/all"
CLUSTER_CONFIG_DIR=/data/cluster_config
DFLT_TMOUT=10

# Set http proxy for the OpenSSL client if one is set
PROXY_CHECK=$(apt-config dump Acquire::http::Proxy | awk '{print $2}' | tr -d \;\")

if [ -z "$PROXY_CHECK" ] ; then
	PROXY_MODE=""
else
	PROXY_MODE="-proxy ${PROXY_CHECK#"http://"}"
fi

if [ -d "$CLUSTER_CONFIG_DIR" ] ; then
	# Clustered setup
	INSTALLATION=cluster
	VAULT_ADDR="https://vault.service.consul:8200"
	# Query Consul to obtain Consul peers (Which are also Vault servers)
	VAULT_SERVERS=$(curl -m ${DFLT_TMOUT} -s http://127.0.0.1:8500/v1/status/peers | jq .[] -r | sed "s/:8300//")
	# Obtain the first Vault server's IP address
	VAULT_1ST_SERVER=$(echo "${VAULT_SERVERS}" | head -1)
	VAULT_INITIALIZED=$(curl -m ${DFLT_TMOUT} -s "https://${VAULT_1ST_SERVER}:8200/v1/sys/health" | jq '.initialized')
	VAULT_SEALED=$(curl -m ${DFLT_TMOUT} -s "https://${VAULT_1ST_SERVER}:8200/v1/sys/health" | jq '.sealed')

	if [ "$UID" != "0" ] && [ ! -r "$CLUSTER_CONFIG_DIR" ] ; then
		# Try to grant read permissions to the required files
		sudo chgrp -R teamwire "$CLUSTER_CONFIG_DIR"
	fi

	NOMAD_JOB="${CLUSTER_CONFIG_DIR}/teamwire.nomad"
	NOMAD="/usr/local/bin/nomad"
else
	# Single server installation
	INSTALLATION=single
	VAULT_ADDR="https://127.0.0.1:8200"
	VAULT_INITIALIZED=$(curl -m ${DFLT_TMOUT} -s "${VAULT_ADDR}/v1/sys/health" | jq '.initialized')
	VAULT_SEALED=$(curl -m ${DFLT_TMOUT} -s "${VAULT_ADDR}/v1/sys/health" | jq '.sealed')

	if [ ! -f "$CONFIG_FILE" ]; then
		echo "ERROR: Missing configuration file ${CONFIG_FILE}!"
		echo "       Please configure the server before using this tool."
		exit 1
	fi

	CONTAINERS="teamwire_notification_server teamwire_beat teamwire_worker teamwire_backend"
fi

IMAGES="teamwire/backend teamwire/notification-server"


if [ "$VAULT_INITIALIZED" != "true" ]; then
	VAULT_INITIALIZED=false
fi

BLACKLIST=("show-tags" "pull" "migrate" "setup" "start" "stop" "rm" "backupdb" "restoredb" "secrets" "restart")

if [[ "$VAULT_INITIALIZED" == "true"  && "$VAULT_SEALED" != "false" && "$2" != "unseal" ]]; then
	for task in "${BLACKLIST[@]}"; do
		if [[ "$@" == *"$task"* ]]; then
			echo "Vault must be unsealed. Please run twctl secrets unseal."
			exit 1
		fi
	done
fi

if [ "$VAULT_INITIALIZED" == "true" ]; then
	VAULT_TOKEN="$(< ~/.vault-token)"
fi

if [[ "$VAULT_INITIALIZED" == "true"  && "$VAULT_SEALED" == "false" ]]; then
	VAULT_AUTH_CHECK="$(curl -m ${DFLT_TMOUT} -s --header "X-VAULT-TOKEN: $VAULT_TOKEN" $VAULT_ADDR/v1/secret | jq -r .errors[])"
	if [ "$VAULT_AUTH_CHECK" == "permission denied" ]; then
		echo "Invalid Vault token, please check the contents of ~/.vault-token."
		exit 1
	fi
fi

vault_read_secrets() {
	local secret_path=$1
	local secret="$(curl -m ${DFLT_TMOUT} -s --header "X-VAULT-TOKEN: $VAULT_TOKEN" $VAULT_ADDR/v1/secret/$secret_path | jq -r '.data| .[]')"
	echo "$secret"
}

# `vault_list` is just a wrapper function needed
# for `get_vault_secret_recursive` function to make
# the code more readable.
vault_list() {
	echo "curl -m ${DFLT_TMOUT} -s --header \"X-Vault-Token: $VAULT_TOKEN\" --request LIST $VAULT_ADDR/v1/secret/$1 | jq -r '.data.keys | map(\"- \(.)\") | .[]'"
}

get_vault_secret_recursive() {
	declare -a vault_secr="$(curl -m ${DFLT_TMOUT} -s --header "X-Vault-Token: $VAULT_TOKEN" --request LIST $VAULT_ADDR/v1/secret/ | jq -r '.data.keys | .[]')"
	for toplevel in ${vault_secr[@]}
	do
		sub="$(vault_list $toplevel)"
		sublevel=`eval "$sub | sed ':a;N;$!ba;s/\n//g'"`
		key=`echo "$sublevel" | sed 's|-\s|  |gm'`
		for k in ${key[@]}
		do
			echo "$toplevel$k"
		done
	done
}

vault_status_single() {
	echo "======================================"
	echo "Vault Status"
	echo "--------------------------------------"
	curl -m ${DFLT_TMOUT} -s $VAULT_ADDR/v1/sys/seal-status | jq -r '. | to_entries[] | ["\(.key):",.value] | @tsv' \
		| awk -v FS="\t" 'BEGIN{printf"%-29.30s %s\n","Key","Value";printf"%-29.30s %s\n","-----","--------"}{printf "%-29.30s %s\n",$1,$2}'
}

vault_status_cluster() {
	for VAULT_SERVER_IP in $VAULT_SERVERS; do
		VAULT_SERVER_NAME="$(dig -x ${VAULT_SERVER_IP} +short | sed '$s/.$//')"
		echo "======================================"
		echo "${VAULT_SERVER_NAME}[${VAULT_SERVER_IP}] Vault Status"
		echo "--------------------------------------"
		curl -m ${DFLT_TMOUT} -s https://"$VAULT_SERVER_IP":8200/v1/sys/seal-status | jq -r '. | to_entries[] | ["\(.key):",.value] | @tsv' \
			| awk -v FS="\t" 'BEGIN{printf"%-29.30s %s\n","Key","Value";printf"%-29.30s %s\n","-----","--------"}{printf "%-29.30s %s\n",$1,$2}'
	done
}

vault_seal() {
		curl -m ${DFLT_TMOUT} -s --header "X-Vault-Token: $VAULT_TOKEN" --request PUT \
			$VAULT_ADDR/v1/sys/seal | jq -r '.errors | .[]'
}

vault_unseal_single() {
	if [ "$VAULT_SEALED" = "false" ];then
		echo "Vault is already unsealed"
	else
		read -s -p "Unseal Key (will be hidden):"$'\n' vault_unseal_key
		echo "======================================"
		echo "Vault Seal Status"
		echo "--------------------------------------"
		curl -m ${DFLT_TMOUT} -s --insecure --request PUT --data "{\"key\":\"$vault_unseal_key\"}" $VAULT_ADDR/v1/sys/unseal | jq -r '. | to_entries[] | ["\(.key):",.value] | @tsv' \
				| awk -v FS="\t" 'BEGIN{printf"%-29.30s %s\n","Key","Value";printf"%-29.30s %s\n","-----","--------"}{printf "%-29.30s %s\n",$1,$2}'
	fi
}

vault_unseal_cluster() {
	read -s -p "Unseal Key (will be hidden):"$'\n' vault_unseal_key
	if [ -n "$INPUT" ];then
		VAULT_SERVERS="$INPUT"
	fi
	for VAULT_SERVER_IP in $VAULT_SERVERS; do
		VAULT_SERVER_NAME="$(dig -x ${VAULT_SERVER_IP} +short | sed '$s/.$//')"
		VAULT_SERVER_SEAL=$(curl -m ${DFLT_TMOUT} -s "https://$VAULT_SERVER_IP:8200/v1/sys/health" | jq '.sealed')
		if [ "$VAULT_SERVER_SEAL" = "false" ];then
			echo "Vault on ${VAULT_SERVER_NAME}[${VAULT_SERVER_IP}] is already unsealed"
		else
			echo "======================================"
			echo "${VAULT_SERVER_NAME}[${VAULT_SERVER_IP}] Vault Seal Status"
			echo "--------------------------------------"
			curl -m ${DFLT_TMOUT} -s --insecure --request PUT --data "{\"key\":\"$vault_unseal_key\"}" https://"$VAULT_SERVER_IP":8200/v1/sys/unseal | jq -r '. | to_entries[] | ["\(.key):",.value] | @tsv' \
				| awk -v FS="\t" 'BEGIN{printf"%-29.30s %s\n","Key","Value";printf"%-29.30s %s\n","-----","--------"}{printf "%-29.30s %s\n",$1,$2}'
		fi
	done
}

vault_backup_cluster() {
	if [ -n "$FILENAME" ]; then
		consul snapshot save "${FILENAME}"
		echo "Backup complete and stored at ${FILENAME}."
	else
		STAMP=$(date +"%Y%m%d%H%M")
		consul snapshot save "secrets-backup-${STAMP}"
		echo "Backup complete and stored at ${PWD}/secrets-backup-${STAMP}."
	fi
}

vault_backup_single() {
	sudo systemctl stop vault
	if [ -n "$FILENAME" ]; then
		sudo tar -zcf "$FILENAME" -C /var/lib/vault/ store/
		echo "Backup complete and stored at ${FILENAME}. You must now unseal the secrets system."
	else
		STAMP=$(date +"%Y%m%d%H%M")
		sudo tar -zcf "secrets-backup-${STAMP}" -C /var/lib/vault/ store/
		echo "Backup complete and stored at ${PWD}/secrets-backup-${STAMP}. You must now unseal the secrets system."
	fi
	sudo systemctl start vault
}

vault_restore_cluster() {
	if [ -z "$INPUT" ] || [ ! -f "$INPUT" ] ; then
		echo "ERROR: Mission valid backup file path, please specify a backup file to restore from."
		exit 1
	else
		consul snapshot restore "${INPUT}"
		if [ $? -eq 0 ] ; then
			echo "Successfully restored $INPUT"
		else
			echo "Error: $INPUT is an invalid backup file."
			exit 1
		fi
	fi
}

vault_restore_single() {
	STAMP=$(date +"%Y%m%d%H%M")
	if [ -z "$INPUT" ] || [ ! -f "$INPUT" ] ; then
		echo "ERROR: Mission valid backup file path, please specify a backup file to restore from."
		exit 1
	else
		sudo systemctl stop vault
		if ! sudo mv /var/lib/vault/store "/var/lib/vault/store_${STAMP}"; then
			echo "ERROR: unable to backup Vault store."
			exit 1
		fi
		if ! sudo tar -xzf "${INPUT}" -C /var/lib/vault; then
			echo "ERROR: unable to restore Vault backup file."
			exit 1
		fi
		if ! sudo systemctl start vault; then
			echo "ERROR: unable to start the Vault service."
			exit 1
		fi
		echo "Successfully restored $INPUT, you must now unseal the secrets system."
	fi
}

_get_config_value() {
	local ENTRY="$1"
	awk '/^'${ENTRY}':/ { gsub("(^\"|\"$)","", $2); print $2 }' "$CONFIG_FILE" 2> /dev/null
}

check_tag() {
	local TAG=$1
	check_registry
	for IMAGE in $IMAGES ; do
		if ! docker images "${PRFX}${IMAGE}" | grep -q "$TAG" ; then
			# Required image not found for given tag
			echo "ERROR: Containers for the requested tag could not be found."
			echo "       Please pull the containers first using the pull action."
			exit 1
		fi
	done
}

get_database_configuration() {
	if [ "$VAULT_INITIALIZED" == "true" ]; then
		AESKEY="$(vault_read_secrets database/aes_key)"
		DB_PASSWORD="$(vault_read_secrets database/password)"
		REDIS_PASSWORD="$(vault_read_secrets redis/password)"
	else
		AESKEY="$(_get_config_value aes_key)"
		DB_PASSWORD="$(_get_config_value teamwire_db_password)"
		REDIS_PASSWORD="$(_get_config_value redis_pass)"
	fi

	if [ -z "$DB_PASSWORD" ] || [ -z "$AESKEY" ] ; then
		echo "ERROR: Cannot read required parameters from $CONFIG_FILE."
		echo "       Please ensure the file exists and the database is configured or"
		echo "       Vault is running and unsealed."
		exit 1
	fi

	if [ "$INSTALLATION" == "cluster" ] ; then
		. "${CLUSTER_CONFIG_DIR}/cluster.conf"
		if [ -z "$MYSQL_HOST" ] && [ -z "$ORA_HOST" ]; then
			MYSQL_HOST=galera.service.consul
		fi
	else
		MYSQL_HOST="$(_get_config_value mysql_host)"
		MYSQL_PORT="$(_get_config_value mysql_port)"
		MYSQL_DATABASE="$(_get_config_value teamwire_db_name)"
		MYSQL_USER="$(_get_config_value teamwire_db_user)"
		ORA_HOST="$(_get_config_value oracle_host)"
		ORA_PORT="$(_get_config_value oracle_port)"
		ORA_DATABASE="$(_get_config_value teamwire_db_name)"
		ORA_USER="$(_get_config_value teamwire_db_user)"

		if [ -z "$MYSQL_HOST" ] && [ -z "$ORA_HOST" ]; then
			MYSQL_HOST=127.0.0.1
		fi

		if [ -z "$MYSQL_PORT" ] && [ -z "$ORA_PORT" ]; then
			MYSQL_PORT=3306
		fi

		if [ -z "$MYSQL_DATABASE" ] && [ -z "$ORA_DATABASE" ]; then
			MYSQL_DATABASE=teamwire
		fi

		if [ -z "$MYSQL_USER" ] && [ -z "$ORA_USER" ]; then
			MYSQL_USER=teamwire
		fi
	fi

	if [ -n "$MYSQL_HOST" ]; then
		MYSQL_PASS="$DB_PASSWORD"
	elif [ -n "$ORA_HOST" ]; then
		ORA_PASSWORD="$DB_PASSWORD"
	fi
}

secrets() {
case $OPTION in
		read)
				vault_read_secrets "$INPUT"
				;;
		write)
				if [ -z "$INPUT" ] ; then
				 echo "ERROR: A secret must be specified, use 'twctl secrets list' for information on current secret paths."
				 echo
				 exit 1
				fi

				echo Setting "${INPUT}"
				read -s -p "Secret: " ENTRY; echo
				read -s -p "Confirm Secret: " ENTRYCONFIRM; echo

				if [[ "${ENTRY}" != "${ENTRYCONFIRM}" ]]; then
				 echo "Entries do not match, exiting"
				 exit 1
				else
				 curl -m ${DFLT_TMOUT} -s --header "X-VAULT-TOKEN: $VAULT_TOKEN" --request POST --data "{\"value\":\"$ENTRY\"}" $VAULT_ADDR/v1/secret/"$INPUT"
				fi
				;;
		list)
				get_vault_secret_recursive
				;;
		delete)
				curl -m ${DFLT_TMOUT} -s --header "X-VAULT-TOKEN: $VAULT_TOKEN" --request DELETE $VAULT_ADDR/v1/secret/"$INPUT"
				;;
		unseal)
				"vault_unseal_${INSTALLATION}"
				;;
		seal)
				vault_seal
				;;
		info)
				"vault_status_${INSTALLATION}"
				;;
		backup)
				"vault_backup_${INSTALLATION}"
				;;
		restore)
				"vault_restore_${INSTALLATION}"
				;;
		*)
				echo "Managing Vault secrets"
				echo "Usage: twctl secrets {read|write|list|delete|unseal|seal|info|backup|restore}"
				echo "	read  : Reads the specified secret"
				echo "	write : Updates the specified secret"
				echo "	list  : Lists the secret paths"
				echo "	delete : Deletes the specified secret"
				echo "	unseal : Unseals the Vault so secrets can be accessed"
				echo "	seal : Seals the Vault to prevent access to secrets"
				echo "	info : Displays Vault information such as seal status, cluster mode and version"
				echo "	backup : Generate encrypted backup of secrets (--file can be specified for the file name)"
				echo "	restore : Restores a secrets backup file"    ;;
esac
}



help() {
	echo "Command line options:"
	echo
	echo "--help      Show help"
	echo "--tag TAG   Specifiy tag for actions that require a tag"
	echo "--file NAME Specify a filename for actions that require it"
	echo
	echo "Actions:"
	echo
	echo "show-tags   	Show available backend tags"
	echo "pull        	Pull containers for a given tag (requires tag)"
	echo "migrate     	Run database migrations (requires tag)"
	echo "setup       	Configure and run Teamwire containers (requires tag)"
	echo "start       	Start all stopped Teamwire containers"
	echo "restart     	Stop and restart all containers"
	echo "stop        	Stop all running Teamwire containers"
	echo "status      	Show status of Teamwire containers (--clean can be specified on clusters to clean container history)"
	echo "rm          	Remove all stopped Teamwire containers"
	echo "backupdb    	Create a backup of the database (requires file name)"
	echo "restoredb   	Restore a backup of the database (requires file name)"
	echo "secrets     	Manage Vault and its secrets"
	echo "version     	Show version information"
	echo "report      	Create a report (system information & logs. --file can be specified for the file name)"
	echo "connectivity 	Test external connections"
	echo "archiving 	Manage organisation archiving {add|remove|list|help} (requires tag and file name)"
	echo "ha-log      	Show content of haproxy.log. Pipe to less -R for pager with colour support"
}

test_server_condition_for_preflight_check() {

	# This function is only used for the preflight-check
		OK='\033[0;32m'
		WARN='\033[0;31m'
		INFO='\033[0;34m'
		ENDMSG='\033[0m'

		eval $1
		local condition_to_test=$?
		local return_message=$2

		if [ "$condition_to_test" == 0 ]; then
			echo -e "${OK}[+]......${ENDMSG}  $return_message"
		elif [ "$condition_to_test" == 1 ]; then
			echo -e "${WARN}[!]......  $return_message${ENDMSG}"
		else
			echo -e "${INFO}[*]......${ENDMSG}  $return_message"
		fi
}

raw_smtp_connect() {
		local mail_recipient=$1
		echo "Debug $mail_recipient"
		(\
		echo "helo localhost";\
		echo "mail from: root";\
		echo "rcpt to: <$mail_recipient>";\
		echo "data";\
		echo "Subject: test connectivity";\
		echo "test";\
		echo ".";\
		echo "quit" ) \
		| nc localhost 25
}

connectivity_test() {

		echo
		echo "Run preflight server check..."
		echo "-----------------------------"
		echo

		test_server_condition_for_preflight_check	"wget --timeout=10 -qO - https://rest.nexmo.com/sms/json | grep -q 'Missing'" \
							"Check first(Nexmo) SMS service reachability"
		test_server_condition_for_preflight_check	"wget --timeout=10 -qO - https://api.twilio.com/2010-04-01 | grep -q 'TwilioResponse'" \
							"Check second(Twilio) SMS service reachability"
		test_server_condition_for_preflight_check	"" \
							"Check your outgoing IP: $(wget --timeout=10 -qO - http://ipinfo.io/ip)"
		local mail_recipient="$(_get_config_value system_email_recipient)"
		if [ -n "$mail_recipient" ] ; then
			local mail_test_response="$(raw_smtp_connect $mail_recipient | tail -n 2 | head -n 1)"
			local mail_message_id="$(echo $mail_test_response |  awk -v RS='\r\n' '{print $6}')"
			local mail_message_status="$(sleep 2 && sudo grep $mail_message_id /var/log/mail.log | grep -oP 'status=\K.*')"
			test_server_condition_for_preflight_check	"" \
								"Local mail test 1/2: $mail_test_response"
			test_server_condition_for_preflight_check	"" \
								"Local mail test 2/2: $mail_message_status"
		else
			test_server_condition_for_preflight_check	"/bin/false" \
								"Local mail test: Fail. Please define 'system_email_recipient' in $CONFIG_FILE"
		fi
		test_server_condition_for_preflight_check	"echo | timeout 10s openssl s_client $PROXY_MODE -connect fcm.googleapis.com:443 2>&1 | grep 'depth=1' | grep -q 'Google'" \
							"Check Google FCM connectivity"
		test_server_condition_for_preflight_check	"echo | timeout 10s openssl s_client $PROXY_MODE -connect api.push.apple.com:443 2>&1 | grep 'depth=1' | grep -q 'CN = Apple'" \
							"Check Apple APNS connectivity"
		test_server_condition_for_preflight_check	"sudo bash -c '/usr/bin/test -e /data/certs/apns/aps-production.pem'" \
							"Check if APNS certificate is installed"
		test_server_condition_for_preflight_check	"" \
							"Check APNS certificate: $(sudo openssl x509 -noout -in /data/certs/apns/aps-production.pem -enddate)"
		test_server_condition_for_preflight_check	"[ -e /usr/local/src/ocsp.sh ] && sudo /usr/local/src/ocsp.sh DO NOT UPDATE" \
							"Check OCSP response"

}

check_registry() {
	shopt -s nocasematch
	USE_TEAMWIRE_REGISTRY="$(_get_config_value use_teamwire_registry)"
	if [ -z "${USE_TEAMWIRE_REGISTRY}" ] || [ "${USE_TEAMWIRE_REGISTRY}" == "false" ];then
		: noop
	else
		PRFX="harbor.teamwire.eu/docker.io/"
	fi
	shopt -p nocasematch
}

show-tags() {
	check_registry
  echo "***** Backend version: *****"
	if [ "${USE_TEAMWIRE_REGISTRY}" == "" ] || [ "${USE_TEAMWIRE_REGISTRY}" == "false" ];then
		local USER="$(_get_config_value dockerhub_username)"
		local PASS="$(vault_read_secrets dockerhub/password)"

		local TOKEN=$(curl -m ${DFLT_TMOUT} -s -H "Content-Type: application/json" -X POST -d '{"username": "'${USER}'", "password": "'${PASS}'"}' https://hub.docker.com/v2/users/login/ | jq -r .token)
		curl -m ${DFLT_TMOUT} -s -H "Authorization: JWT ${TOKEN}" "https://registry.hub.docker.com/v2/repositories/teamwire/backend/tags/?name=prod&page_size=100" | jq -r '.results[].name'
	else
		curl -m ${DFLT_TMOUT} -s "https://harbor.teamwire.eu:8000/tags" | jq -r '.results[].name'
	fi
}

create_report() {
	echo "Generating report. Please wait..."

	PLATFORM_HOME="$HOME/platform"	# Path to platform dir
	TMPDIR=$(mktemp -d)				# A temporary directory to collect all information that will later be stored in a tar archive.

	FILE="${TMPDIR}/report"			# Path to report file. All collected informations are stored here.
	if [ -z "$FILENAME" ]; then
		REPORT="tw_report.$(date +%y_%m_%d_%s).tar.xz" 	# Name/Path of the tar archive
	else
		if [[ "$FILENAME" == *"tar.xz" ]]; then
			REPORT="$FILENAME"
		else
			echo 'ERROR: Filename must end with ".tar.xz" !'
			exit 1
		fi
	fi
	RUNTIME_REPORT_OF_SCRIPT="${TMPDIR}/runtime_report" # All outputs from twctl (STDOUT/STDERR) are collected here. See line below

	exec > >(tee -i "$RUNTIME_REPORT_OF_SCRIPT")
	exec 2>&1

	declare -A report_map			# Array contains all collected information. This array will be looped and written to a report file

	# Gather systeminformation

	if [ "$INSTALLATION" = "cluster" ]; then

		report_map["Show cluster uptime"]=$(ansible all -i "${ANSIBLE_DIR}/cluster_hosts" -m command -a uptime) &&
		report_map["Show nomad status"]="$(nomad status)" &&
		report_map["Show nomad job status"]="$(nomad job status teamwire)" &&
		report_map["Show debian version"]=$(ansible all -i "${ANSIBLE_DIR}/cluster_hosts" -m command -a 'cat /etc/debian_version') &&
		report_map["Show nomad node status"]="$(nomad node status)"
		report_map["Show consul info"]="$(consul info)"
		report_map["Show consul members"]="$(consul members)"
		report_map["Show consul raft peer list"]="$(consul operator raft list-peers)"
		report_map["Consul validate config "]="$(consul validate /etc/consul.d/)"
		report_map["Show last 15 consul messages"]="$(sudo journalctl -u consul --lines 30)"
		report_map["Show last 15 nomad messages"]="$(sudo journalctl -u nomad --lines 30)"

		# Retrieve logs from loghost and add them to the report
		LOG_SERVER=$(ansible -i "${ANSIBLE_DIR}/cluster_hosts" loghost['0'] -m setup -a "filter=ansible_hostname" | grep ansible_hostname | awk '{print $2}' | tr -d '",')
		LOG_FILES=$(ssh "teamwire@${LOG_SERVER}" "find /var/log/cluster -name \"*.log"\" | awk -F/ '{print $NF}')
		for LOG_FILE in $LOG_FILES; do
			ansible -i "${ANSIBLE_DIR}/cluster_hosts" loghost['0'] -b -m fetch -a "src=/var/log/cluster/$LOG_FILE dest=$TMPDIR/ flat=yes" > /dev/null 2>&1
		done
		ansible -i "${ANSIBLE_DIR}/cluster_hosts" frontend_servers['0'] -b -m fetch -a "src=/var/log/haproxy.log dest=$TMPDIR/ flat=yes" > /dev/null 2>&1

	else

		report_map["Show uptime"]=$(uptime)
		report_map["Show running docker container"]="$(docker ps -a)"
		report_map["Show debian version"]=$(cat /etc/debian_version)

	fi

	report_map["Check if self signed cert is defined"]="$(grep 'ssl_certfile' ${ANSIBLE_DIR}/group_vars/all || echo 'NOT DEFINED')"
	report_map["Show platform version(checkout)"]="$(git --git-dir=${ANSIBLE_DIR}/../.git describe --always)"
	report_map["Show platform version(applied)"]="$(cat /etc/platform_version)"
	report_map["Show git diff command"]="$(cd $PLATFORM_HOME && git diff)"
	report_map["Show git logs"]="$(cd $PLATFORM_HOME && git log --oneline -n 15 )" &&
	report_map["Show status of vault"]="$(vault_status_${INSTALLATION})" &&
	report_map["Check if APNS certificate is valid"]=$(sudo bash -c "for file in /data/certs/apns/*.pem;do echo \$file && openssl x509 -startdate -enddate  -noout -in \$file 2>&1 ;done")
	report_map["Test if APNS is reachable"]="$(echo | timeout 10s openssl s_client $PROXY_MODE -connect api.push.apple.com:2197 2>&1 | grep 'depth=1')"
	report_map["Test if FCM is reachable"]="$(echo | timeout 10s openssl s_client $PROXY_MODE -connect fcm.googleapis.com:443 2>&1 | grep 'depth=1')"
	report_map["Show vault certificate enddate"]="$(sudo openssl x509 -in /var/lib/vault/ssl/vault.crt -noout -enddate)"
	report_map["Show RAM"]="$(free -h )"
	report_map["Show HDD free space"]="$(df -h)"
	report_map["Show docker info"]="$(docker info)"
	report_map["Show network configuration"]="$(ip a)"
	report_map["Show current kernel messages(dmesg)"]="$(sudo dmesg | egrep -v 'apt-daily|UFW BLOCK' | tail -n 50)"

	for key in "${!report_map[@]}"; do

		printf "============ $key ============ \n %s\n\n"  "${report_map[$key]}" >> "$FILE"

	done

	# Retrieve docker logs on single installations and management servers
	find /var/log/docker/ -name *.log -exec sudo cp {} "$TMPDIR" \;
	find /var/log/* -maxdepth 0 -type f -name haproxy.log  -exec sudo cp {} "$TMPDIR" \;

	# copy ansible config
	cp -f "${ANSIBLE_DIR}/cluster_hosts" "${ANSIBLE_DIR}/hosts" "${ANSIBLE_DIR}/group_vars/all" "$TMPDIR" 2>/dev/null

	REPORT_PASS=$(vault_read_secrets reportfile/password)
	if [ ${REPORT_PASS} != "reportfile_password" ]; then
		REPORT="${REPORT}.enc"
		if [[ ! $(</etc/debian_version) =~ ^[9] ]];then
			sudo tar JcP -C "$TMPDIR" . | openssl enc -e -aes-256-cbc -iter 1000000 -out "${REPORT}" -k "${REPORT_PASS}"
		else
			sudo tar JcP -C "$TMPDIR" . | openssl enc -e -aes-256-cbc -out "${REPORT}" -k "${REPORT_PASS}"
		fi
	else
	   sudo tar JcfP "$REPORT" -C "$TMPDIR" .
	fi

	rm -rf "$TMPDIR"

	if [ -z "$FILENAME" ]; then
		echo "The report was generated and saved as $REPORT in the current directory."
	else
		echo "The report was generated and saved as $REPORT"
	fi
	echo
}

backupdb() {
	if [ -f "$FILENAME" ] ; then
		echo "$FILENAME exists, please specify a name that doesn't exist!"
		exit 1
	fi

	get_database_configuration

	if [ -n "$ORA_HOST" ]; then
		echo "Backing up of Oracle databases is not supported."
		exit 1
	fi

	# Inject PASS environment var
	export PASS=$MYSQL_PASS

	/usr/local/bin/backup_restore_db.sh -t backup \
		-o "$FILENAME" -h "$MYSQL_HOST" \
		-u "$MYSQL_USER" -d "$MYSQL_DATABASE"
}

restoredb() {
	if [ ! -f "$FILENAME" ] ; then
		echo "$FILENAME does not exist, please specify a name that exists!"
		exit 1
	fi

	get_database_configuration

	if [ -n "$ORA_HOST" ]; then
		echo "Restoration of Oracle databases is not supported."
		exit 1
	fi

	# Inject PASS environment var
	export PASS=$MYSQL_PASS

	/usr/local/bin/backup_restore_db.sh -t restore \
		-u "$MYSQL_USER" -d "$MYSQL_DATABASE" \
		-f -i "$FILENAME" -h "$MYSQL_HOST"
}

pull_images_base() {
	echo "Pulling Teamwire container images for version $TAG"
	echo
	check_registry
	for IMAGE in $IMAGES; do
		docker pull "${PRFX}$IMAGE":"$TAG"
	done
}

pull_images_single() {
	pull_images_base
}

pull_images_cluster() {
	pull_images_base

	. "${CLUSTER_CONFIG_DIR}/cluster.conf"
	if [ -n "$REGISTRY" ] && [ -x /usr/local/bin/twimg ] ; then
		echo
		echo "Pushing images to registry"
		/usr/local/bin/twimg --registry "$REGISTRY" push
	fi
}

remove_containers_single() {
	for CONTAINER in $CONTAINERS; do
		docker rm "$CONTAINER"
	done
}

remove_containers_cluster() {
	echo "On clustered setups containers are deleted when stopped."
	exit 1
}

run_migrations_base() {
	check_tag "$TAG"
	get_database_configuration
	check_registry
	echo "Running database migrations"
	echo
	docker run --rm --network host -e MODE=migration --name teamwire-migrations \
		--log-driver syslog --log-opt syslog-facility=local6 --log-opt tag=teamwire-migrations \
		-e MYSQL_HOST="$MYSQL_HOST" -e MYSQL_PORT="$MYSQL_PORT" -e MYSQL_DATABASE="$MYSQL_DATABASE" \
		-e MYSQL_USER="$MYSQL_USER" -e MYSQL_PASSWORD="$MYSQL_PASS" \
		-e ORA_HOST="$ORA_HOST" -e ORA_PORT="$ORA_PORT" -e ORA_DATABASE="$ORA_DATABASE" \
		-e ORA_USER="$ORA_USER" -e ORA_PASSWORD="$ORA_PASSWORD" \
		-e REDIS_URI="$REDIS_URI" -e REDIS_PASSWORD="$REDIS_PASSWORD"\
		-e AESKEY="$AESKEY" "${PRFX}teamwire/backend:${TAG}" 2>&1

}

run_migrations_single() {
	REDIS_URI='127.0.0.1:6379:1'
	run_migrations_base
}

run_migrations_cluster() {
	REDIS_URI='redis.service.consul:6379:1'
	run_migrations_base
}

status_single() {
	docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Image}}\t{{.RunningFor}}\t{{.Status}}"
}

status_cluster() {
	if [ "$OPTION" = "--clean" ]; then
		curl -m ${DFLT_TMOUT} -XPUT http://127.0.0.1:4646/v1/system/gc
		echo "Container history cleaned"
	else
		$NOMAD status teamwire
	fi
}

stop_containers_single() {
	for CONTAINER in $CONTAINERS; do
		if docker ps -qf name="$CONTAINER" | grep -Eq '^.+$' ; then
			docker stop "$CONTAINER"
		fi
	done
}

stop_containers_cluster() {
	$NOMAD stop teamwire
}

start_containers_single() {
	for CONTAINER in $CONTAINERS; do
		docker start "$CONTAINER"
	done
}

start_containers_cluster() {
	$NOMAD run "$NOMAD_JOB"
}

restart_containers_single() {
	stop_containers_single
	start_containers_single
}
restart_containers_cluster() {
	stop_containers_cluster
	start_containers_cluster
}

setup_containers_base() {
	check_tag "$TAG"

	if [ -z "$(_get_config_value version)" ] ; then
		echo "ERROR: Please update the configuration file ${CONFIG_FILE}"
		echo "       from the provided example before using this action. "
		exit 1
	fi

	# Write given tag into config file
	sed -i -e 's/^\(version: \).*$/\1'"$TAG"'/' $CONFIG_FILE
}

setup_containers_single() {
	setup_containers_base

	ansible-playbook -i "${ANSIBLE_DIR}/hosts" "${ANSIBLE_DIR}/playbooks/roles/container.yml"
}

setup_containers_cluster() {
	setup_containers_base

	ansible-playbook -i "${ANSIBLE_DIR}/cluster_hosts" "${ANSIBLE_DIR}/playbooks/roles/container.yml"
	$NOMAD run "$NOMAD_JOB"
}

ha-log() {
	local LOG_FILE="/var/log/haproxy.log"
	sudo cat "${LOG_FILE}" | grep --line-buffered -o -P '(?<=LIMSTART).*(?=LIMEND)' | jq . -C
}

get_latest_tag() {
  local latestFile="/etc/latest_remote_github_version"

  if [ ! -e "${latestFile}" ] || [[ $(find "/etc/latest_remote_github_version" -mtime +1 -print) ]];then
     local HEAD=$(git --git-dir=${ANSIBLE_DIR}/../.git ls-remote 2>/dev/null | grep 'HEAD' | awk '{print $1}')
     local LATEST=$(git --git-dir=${ANSIBLE_DIR}/../.git ls-remote 2>/dev/null | grep "${HEAD}" | grep -v -i 'HEAD' | awk '{print $2}')
     sudo bash -c "echo $(grep -oP '[0-9]+\.[0-9]+' <<<${LATEST}) > ${latestFile}"
     sudo chmod 0644 "${latestFile}"
  fi
}

version() {
check_registry
get_latest_tag
        echo "#### Version information ####
Installation type: ${INSTALLATION}
Platform (checkout): $(git --git-dir=${ANSIBLE_DIR}/../.git describe --always)
Platform (applied) : $(cat /etc/platform_version 2>/dev/null)
Platform (latest)  : $(</etc/latest_remote_github_version)
Ansible: $(ansible --version | awk 'NR==1{print $2}')
Vault enabled: ${VAULT_INITIALIZED}"
[ "${USE_TEAMWIRE_REGISTRY}" == "true" ] && echo "
Harbor check IP: $(curl -s https://harbor.teamwire.eu:8000/loopback | jq . )"
}


archiving() {
	if [ ! -f "/data/archiving/archiving.conf" ]; then
		sudo touch /data/archiving/archiving.conf
		if [ $? != 0 ]; then
			echo "archiving.conf does not exist and could not be created! Exit now"
			exit 1
		fi
	fi

	case $OPTION in
			add)
					if hash archiving 2>/dev/null; then
						sudo archiving -add -tag $TAG -file $FILENAME
					else
						echo "Archiving app not found"
					fi
					;;
			remove)
					if hash archiving 2>/dev/null; then
						sudo archiving -del -tag $TAG -file $FILENAME
					else
						echo "Archiving app not found"
					fi
					;;
			*)
					echo "Managing organisation archiving"
					echo "Usage: twctl archiving {add|remove|list}"
					echo
					echo "--tag TAG 	set organisation name"
					echo "--file NAME	path to user public key"
					echo;echo
					echo "	add:	adds a new user to organisation for archiving"
					echo "	remove:	removes a user from organisation"
					echo "	list:	show current archiving user/orgs as ini file"
					echo "	*: 		displays this message"
					;;
	esac
}

TAG=""
TASK=""
while [ $# -gt 0 ] ; do
	case "$1" in
		-h|--help)
			help
			exit
			;;
		-t|--tag)
			TAG=$2
			shift
			;;
		-f|--file)
			FILENAME=$2
			shift
			;;
		pull)
			TASK="pull_images"
			TAG_REQUIRED=yes
			;;
		migrate)
			TASK="run_migrations"
			TAG_REQUIRED=yes
			;;
		setup)
			TASK="setup_containers"
			TAG_REQUIRED=yes
			;;
		start)
			TASK="start_containers"
			;;
		status)
			TASK="status"
			OPTION="$2"
			;;
		stop)
			TASK="stop_containers"
			;;
		restart)
			TASK="restart_containers"
			;;
		rm)
			TASK="remove_containers"
			;;
		show-tags)
			TASK="show-tags"
			;;
		backupdb)
			TASK="backupdb"
			FILENAME_REQUIRED=yes
			;;
		restoredb)
			TASK="restoredb"
			FILENAME_REQUIRED=yes
			;;
		secrets)
			TASK="secrets"
			OPTION="$2"
			INPUT="$3"
			;;
		report)
			TASK="create_report"
			;;
		version)
			TASK="version"
			;;
		connectivity)
			TASK="connectivity_test"
			;;
		archiving)
            if [ $2 == "list" ];then
                sudo cat /data/archiving/archiving.conf
                exit 0
            else
               TASK="archiving"
               FILENAME_REQUIRED=yes
               TAG_REQUIRED=yes
               OPTION="$2"
            fi
            ;;
		ha-log)
			TASK="ha-log"
			;;
	esac
	shift
done

if [ -z "$TASK" ] ; then
	echo "ERROR: Mission action"
	echo
	help
	exit 1
fi

if [ "$TAG_REQUIRED" = "yes" ] && [ -z "$TAG" ] ; then
	echo "ERROR: Please specify a release tag!"
	echo
	help
	exit 1
fi

if [ "$FILENAME_REQUIRED" = "yes" ] && [ -z "$FILENAME" ] ; then
	echo "ERROR: Please specify a file name!"
	echo
	help
	exit 1
fi

if type -t "$TASK" | grep -q "function$" ; then
	"$TASK"
else
	"${TASK}_${INSTALLATION}"
fi
